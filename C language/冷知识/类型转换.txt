类型转换是C语言中常识性的知识点，但不注意又会有让人迷惑的时候，来看一道笔试题：
以下两个程序片段A和B，问那个for循环能运行？
A：
unsigned short i; 
unsigned short index=0; 

for(i = 0; i <index-1; i++)
{
   ... ...
}
B: 
unsigned short i; 
unsigned long index=0; 

for(i = 0; i <index-1; i++) {
{
   ... ...
}
答案是A不能进入循环，B能。原因如下：
 
1、在程序片段A中，index是无符号短整型unsigned short，因此，当执行到语句 i<index-1 时，由于类型不匹配，右边的index和1相减时会发生
隐式类型转换 ，转换的规则是低精度类型向高精度类型转换，即index将被转换成有符号整型 ，转换之后的index还是0，因此程序片段A中的
index-1的结果就是 -1 ，此时判断 i<index-1，即 0<-1，显然不成立。立即退出循环。
 
2、在程序片段B中，index是无符号长整型unsigned long，因此，当执行到语句 i<index-1 时，由于类型不匹配，右边的index和1相减时也会发
生由低精度类型向高精度方向的隐式类型转换 ，即1将被转换成无符号长整型 ，因此程序片段B中的index-1的过程用十六进制数表示实际上就是
0x0000-0x0001=0xffff，此时再把左边的 i 隐式转换成无符号长整型之后判断 i<index-1，即 0<0xffff，显然成立。立即进入循环。
 
语句和表达式通常应该是只使用一种类型的变量和常量，但如果你使用了混合类型，C则会用一个规则集合来自动完成类型的转换。这可能很方便，
但也可能很危险，尤其在你无意地混合使用了不同类型的情况下。
 
隐式类型转换规则：
C语言自动转换不同类型的行为称之为隐式类型转换 ，转换的基本原则是：低精度类型向高精度类型转换，具体是：
           int -> unsigned int -> long -> unsigned long -> long long -> unsigned long long -> float -> double -> long double
注意，上面的顺序并不一定适用于你的机器，比如当int和long具有相同字长时，unsigned int的精度就会比long的精度高(事实上大多数针对32
机的编译器都是如此)。另外需要注意的一点是并没有将char和short型写入上式，原因是他们可以被提升到int也可能被提升到unsigned int。
 
提升数据的精度通常是一个平滑无损害的过程，但是降低数据的精度可能导致真正的问题。原因很简单：一个较低精度的类型可能不够大，不能存
放一个具有更高精度的完整的数据。一个1字节的char变量可以存放整数101但不能存放整数12345。当把浮点类型数据转换为整数类型时，他们被
趋零截尾或舍入。

强制类型转换：
通常我们应该避免自动类型转换，当我们需要手动指定一个准确的数据类型时，我们可以用强制类型转换机制来达到我们的目的，使用方法很简单，
在需要强制转换类型的变量或常量前面加上(type)，例如(double)i; 即把变量 i 强制转换成double型。