链接的接口-符号
链接的过程的本质就是要把多个不同目标文件之间相互“粘”到一起。或者说像玩具积木一样，可以拼装成一个整体。为了使不同目标文件之间能够相互黏合，这些目标文件之间必须有固定的规则才行，就像积木模块必须有凹凸部分才能相互黏合。**在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。**  
比如目标文件B要用到目标文件中的函数“foo”，那么我们就成目标文件A定义（Define）了函数“foo”，称目标文件B引用（Reference）了目标文件A中的函数“foo”。这两个概念也同样适用于变量。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。  
我们可以将符号看作是链接中的粘合剂，整个链接过程正是基于符号才能够完成。链接过程中很关键的一部分是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里记录了目标文件所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址，除了函数和变量之外，还存在着其他几种不常用的符号。我们将符号表中的所有符号进行分类，它们有可能是下面这些类型中的几种：  

 - 定义在本目文件中的全局符号，可以被其他目标文件引用，比如SimpleSection.o里面的“func1”、“main”和“global_init_val”。
 - 在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），也就是我们前面所讲的符号引用。比如SimpleSection.o里面的“printf”
 - 段名，这种符号往往是由编译器产生，它的值就是该段的起始地址。
 - 局部符号，这类符号只在编译单元内部可见。
 - 行号信息。
 对于我们来说，最值得关注的是全局符号，即上面的第一类和第二类。  