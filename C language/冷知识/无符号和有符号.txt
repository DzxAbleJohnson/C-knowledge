无符号和有符号数相加的话，有符号数会自动转换成无符号数；
如：

void foo(void)
{
	unsigned int a = 6;
	int b = -20;
	(a+b)>6?puts(">6"):puts("<6");
}

隐式类型转换分三种，即算术转换、赋值转换和输出转换。


1．算术转换

    进行算术运算（加、减、乘、除、取余以及符号运算）时，不同类型数招必须转换成同 一类型的数据才能运算，算术转换原则为：

    整型提升：对于所有比int小的类型，包括char, signed char, unsigned char, short, unsigned short,首先会提升为int类型。

    在进行运算时，以表达式中最长类型为主，将其他类型位据均转换成该类型，如：

(1)若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。

(2)若运算数中最长的类型为long型．则其他类型数均转换成long型数。

(3)若运算数中最长类型为int型，则char型也转换成int型进行运算。算术转换是在运算过程中自动完成的。

    特别注意的是有符号和无符号之间的转换：

    包含long与unsigned int,32位机器上都是4字节，所以均转换为unsigned long.

    包含signed与unsigned int，signed会转换为unsigned。如果int恰好为负数，其结果为对unsigned取值个数求模的结果。比如将-1赋给8位的unsigned char，呢么结果就是255（-1对256取模后的值）。unsigned char取值范围0~255。



注意：在进行自动类型转换的时候，如果原来的数是无符号数，那么在扩展的时候，高位填充的是0；如果是有符号数，那么高位填充的时符号位！

2．赋值转换

    进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行截断或舍入操作。

下面用一实例说明：

      char ch;

      int i,result;

      float f;

      double d;

      result=ch/i+(f*d-i);

(1)首先计算 ch/i,ch → int型，ch/i → int型。

(2)接着计算 f*d-i，由于最长型为double型，故f→double型，i→double型，f*d-i→double型。

(3)(ch/i) 和(f*d-i)进行加运算，由于f*d-i为double型，故ch/i→double型，ch/i+(f*d-i)→double型。

(4)由于result为int型，故ch/i+(f*d-i)→double→int，即进行截断与舍入，最后取值为整型。

3．输出转换

    在程序中将数据用printf函数以指定格式输出时，当要输出的盐据类型与输出格式不符时，便自动进行类型转换，如一个long型数据用整型格式(%d)输出时，则相当于将long型转换成整型(int)数据输出；一个字符(char）型数据用整型格式输出时，相当于将char型转 换成int型输出。

注意：较长型数据转换成短型数据输出时，其值不能超出短型数据允许的值范围，否则 转换时将出错。如：

      long a=80000;

      printf("%d",a);

运行结果为14464，因为int型允许的最大值为32767，80000超出此值，故结果取以32768为模的余数，即进行如下取余运算：

      (80000-32768)-32768=14464;

输出的数据类型与输出格式不符时常常发生错误，如：

      int d=9;

      printf("%f",d);

或

      float c=3.2;

      printf("%d",c);

将产生错误的结果。