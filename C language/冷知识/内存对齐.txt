对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。
比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，举个例：





为了提高程序的性能，数据结构应该尽可能的在自然边界上对齐。原因在于：为了访问未对齐的内存，处理器需要做两次内存访问；然而，对齐的内存访问仅需要一次访问；
一个字或双字操作数跨越了4个字节边界，或者一个四字节操作数跨越了8个字节边界，被认为是未对齐的，从而需要两次的总线周期来访问内存。一个字起始地址是奇数，
但却没有跨越字边界被认为是对齐的，能够在一个总线周期中被访问；
1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2、性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
对齐规则

1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

win32平台下的微软c编译器
1）、结构体变量的首地址是其最长基本类型成员的整数倍；


什么时候需要内存对齐？
在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样.


struct  stu
{
	int name[10];
		//1个字节，内存对齐为2个字节
	int length;
	char sex;
};

10*4+4+1+3（自动补齐4）=48