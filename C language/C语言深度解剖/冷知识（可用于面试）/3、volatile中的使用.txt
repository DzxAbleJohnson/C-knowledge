先看看下面的例子：
int i=10;
int j = i； //(1)语句
int k = i； //(2)语句
这时候编译器对代码进行优化，因为在（ 1）、（ 2）两条语句中， i 没有被用作左值。这时候
编译器认为 i 的值没有发生改变，所以在（ 1）语句时从内存中取出 i 的值赋给 j 之后，这个
值并没有被丢掉，而是在（ 2）语句时继续用这个值给 k 赋值。编译器不会生成出汇编代码
重新从内存里取 i 的值，这样提高了效率。但要注意：（ 1）、（ 2）语句之间 i 没有被用作左
值才行。


例如： 
volatile int i=10; 
int j = i; 
... 
int k = i; 
volatile 告诉编译器i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的可执行码会重新从i的地址
读取数据放在k中。 


嵌入式编程中经常用到 volatile这个关键字，在网上查了下他的用法可以归结为以下两点：

一：告诉compiler不能做任何优化

比如要往某一地址送两指令： 
int *ip =...; //设备地址 
*ip = 1; //第一个指令 
*ip = 2; //第二个指令 
以上程序compiler可能做优化而成： 
int *ip = ...; 
*ip = 2; 
结果第一个指令丢失。如果用volatile, compiler就不允许做任何的优化，从而保证程序的原意： 
volatile int *ip = ...; 
*ip = 1; 
*ip = 2; 
即使你要compiler做优化，它也不会把两次付值语句间化为一。它只能做其它的优化。这对device driver程序员很有用。

二：表示用volatile定义的变量会在程序外被改变,每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用。

 如 volatile char a;
 a=0; 
while(!a){ 
//do some things;
}
doother(); 
如果没有 volatile doother()不会被执行