#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
	int i=0;
	char a[1000];		//未初始化
	for(i=0; i<1000; i++)
	{
		a[i] = -1-i;
	}
	printf("%d\n", strlen(a));
	return 0;
}

/*
    按照负数补码的规则，可以知道-1 的补码为 0xff， -2 的补码为 0xfe……当 i 的值为 127
时， a[127]的值为-128，而-128 是 char 类型数据能表示的最小的负数。当 i 继续增加， a[128]
的值肯定不能是-129。因为这时候发生了溢出， -129 需要 9 位才能存储下来，而 char 类型
数据只有 8 位，所以最高位被丢弃。剩下的 8 位是原来 9 位补码的低 8 位的值，即 0x7f。
当 i 继续增加到 255 的时候， -256 的补码的低 8 位为 0。然后当 i 增加到 256 时， -257 的补
码的低 8 位全为 1，即低八位的补码为 0xff，如此又开始一轮新的循环……
    按照上面的分析， a[0]到 a[254]里面的值都不为 0，而 a[255]的值为 0。 strlen 函数是计
算字符串长度的，并不包含字符串最后的‘ \0’。而判断一个字符串是否结束的标志就是看
是否遇到‘ \0’。如果遇到‘ \0’，则认为本字符串结束。
*/
